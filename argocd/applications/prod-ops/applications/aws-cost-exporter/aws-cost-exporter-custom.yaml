apiVersion: v1
kind: Namespace
metadata:
  name: finops
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: aws-cost-exporter
  namespace: finops
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::586794457112:role/darey-io-v2-lab-prod-ops-aws-cost-exporter-role
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aws-cost-exporter
  template:
    metadata:
      labels:
        app: aws-cost-exporter
    spec:
      serviceAccountName: aws-cost-exporter
      containers:
        - name: exporter
          image: python:3.11-slim
          env:
            - name: AWS_REGION
              value: "eu-west-2"
            - name: INITIAL_CREDITS_AMOUNT
              value: "25000"  # Initial promotional credit: $25,000.00 (AWS Activate - alx ventures)
          command: ["/bin/sh"]
          args:
            - -c
            - |
              pip install -q boto3 prometheus-client flask && \
              python -c "
              import os
              import boto3
              from datetime import datetime, timedelta
              from prometheus_client import Gauge, start_http_server
              import time

              # Initialize AWS clients
              ce = boto3.client('ce', region_name=os.environ.get('AWS_REGION', 'eu-west-2'))
              
              # Get initial credits amount from environment variable
              try:
                  initial_credits = float(os.environ.get('INITIAL_CREDITS_AMOUNT', '0'))
              except (ValueError, TypeError):
                  initial_credits = 0.0

              # Prometheus metrics
              current_month_cost = Gauge('aws_cost_exporter_current_month_cost', 'Current month cost', ['currency'])
              daily_cost = Gauge('aws_cost_exporter_daily_cost', 'Daily cost', ['date', 'currency'])
              forecasted_monthly = Gauge('aws_cost_exporter_forecasted_monthly_cost', 'Forecasted monthly cost', ['currency'])
              service_cost = Gauge('aws_cost_exporter_service_cost', 'Cost by service', ['service_name', 'currency'])
              remaining_credits = Gauge('aws_cost_exporter_remaining_credits', 'Remaining credits')

              def get_cost_and_usage(start, end, granularity='DAILY', group_by=None):
                  params = {
                      'TimePeriod': {'Start': start, 'End': end},
                      'Granularity': granularity,
                      'Metrics': ['BlendedCost']
                  }
                  if group_by:
                      params['GroupBy'] = group_by
                  return ce.get_cost_and_usage(**params)

              def update_metrics():
                  today = datetime.now()
                  month_start = today.replace(day=1).strftime('%Y-%m-%d')
                  today_str = today.strftime('%Y-%m-%d')
                  tomorrow_str = (today + timedelta(days=1)).strftime('%Y-%m-%d')
                  
                  # Current month cost
                  # Use DAILY granularity for partial months to get accurate sum
                  # MONTHLY granularity with partial month periods can return incorrect values
                  try:
                      result = get_cost_and_usage(month_start, today_str, 'DAILY')
                      if result['ResultsByTime']:
                          # Sum all daily costs for accurate partial month total
                          total_cost = sum(float(day['Total']['BlendedCost']['Amount']) 
                                          for day in result['ResultsByTime'])
                          currency = result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                          current_month_cost.labels(currency=currency).set(total_cost)
                  except Exception as e:
                      print(f'Error getting current month cost: {e}')
                  
                  # Daily cost
                  try:
                      result = get_cost_and_usage((today - timedelta(days=1)).strftime('%Y-%m-%d'), today_str, 'DAILY')
                      if result['ResultsByTime']:
                          cost = float(result['ResultsByTime'][0]['Total']['BlendedCost']['Amount'])
                          currency = result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                          daily_cost.labels(date=(today - timedelta(days=1)).strftime('%Y-%m-%d'), currency=currency).set(cost)
                  except Exception as e:
                      print(f'Error getting daily cost: {e}')
                  
                  # Cost by service
                  try:
                      result = get_cost_and_usage(month_start, today_str, 'MONTHLY', [{'Type': 'DIMENSION', 'Key': 'SERVICE'}])
                      if result['ResultsByTime']:
                          for group in result['ResultsByTime'][0]['Groups']:
                              service = group['Keys'][0] if group['Keys'] else 'Unknown'
                              cost = float(group['Metrics']['BlendedCost']['Amount'])
                              currency = group['Metrics']['BlendedCost']['Unit']
                              service_cost.labels(service_name=service, currency=currency).set(cost)
                  except Exception as e:
                      print(f'Error getting service cost: {e}')
                  
                  # Forecasted monthly cost (estimate based on current month average daily rate)
                  try:
                      month_result = get_cost_and_usage(month_start, today_str, 'MONTHLY')
                      if month_result.get('ResultsByTime'):
                          days_elapsed = (today - today.replace(day=1)).days + 1
                          if days_elapsed > 0:
                              current_cost = float(month_result['ResultsByTime'][0]['Total']['BlendedCost']['Amount'])
                              daily_avg = current_cost / days_elapsed
                              forecasted = daily_avg * 30
                              currency = month_result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                              forecasted_monthly.labels(currency=currency).set(forecasted)
                  except Exception as e:
                      print(f'Error calculating forecasted monthly cost: {e}')
                  
                  # Remaining credits - calculate as: initial_credits - credits_applied_this_month
                  # Formula: Remaining = INITIAL_CREDITS_AMOUNT - credits_applied_this_month_from_query
                  # The query result ($1,827.91 for Nov) represents credits applied month-to-date
                  # Initial credits amount is configurable via INITIAL_CREDITS_AMOUNT environment variable
                  try:
                      # Get cost data grouped by RECORD_TYPE to identify credits applied this month
                      # This gives us the month-to-date credits applied (e.g., $1,827.91 for November)
                      credit_result = get_cost_and_usage(month_start, today_str, 'DAILY', [{'Type': 'DIMENSION', 'Key': 'RECORD_TYPE'}])
                      credits_applied_this_month = 0.0
                      if credit_result.get('ResultsByTime'):
                          for day_result in credit_result['ResultsByTime']:
                              if day_result.get('Groups'):
                                  for group in day_result['Groups']:
                                      record_type = group['Keys'][0] if group['Keys'] else 'Unknown'
                                      cost = float(group['Metrics']['BlendedCost']['Amount'])
                                      # Credits appear as negative values with RECORD_TYPE='Credit'
                                      if 'Credit' in record_type:
                                          credits_applied_this_month += abs(cost)
                      
                      # Calculate remaining: initial_credits - credits_applied_this_month
                      # Example: $25,000 - $1,827.91 = $23,172.09
                      remaining = max(0.0, initial_credits - credits_applied_this_month)
                      remaining_credits.set(remaining)
                      
                      if initial_credits == 0:
                          print('WARNING: INITIAL_CREDITS_AMOUNT not set. Remaining credits will be 0.')
                      else:
                          msg = 'Credits calculation: {:.2f} (initial) - {:.2f} (applied this month) = {:.2f} (remaining)'.format(initial_credits, credits_applied_this_month, remaining)
                          print('$' + msg)
                  except Exception as e:
                      print(f'Error calculating remaining credits: {e}')
                      # Fallback to 0 if calculation fails
                      remaining_credits.set(0)

              # Start Prometheus metrics server
              start_http_server(8080)

              # Update metrics immediately on startup
              update_metrics()

              # Update metrics every hour
              while True:
                  time.sleep(3600)
                  update_metrics()
              "
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /metrics
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /metrics
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: metrics
  selector:
    app: aws-cost-exporter
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
    release: kube-prometheus-stack
spec:
  selector:
    matchLabels:
      app: aws-cost-exporter
  endpoints:
    - port: metrics
      interval: 1m
      scrapeTimeout: 30s
      path: /metrics
