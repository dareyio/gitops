apiVersion: v1
kind: Namespace
metadata:
  name: finops
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: aws-cost-exporter
  namespace: finops
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::586794457112:role/darey-io-v2-lab-prod-ops-aws-cost-exporter-role
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aws-cost-exporter
  template:
    metadata:
      labels:
        app: aws-cost-exporter
    spec:
      serviceAccountName: aws-cost-exporter
      containers:
        - name: exporter
          image: python:3.11-slim
          command: ["/bin/sh"]
          args:
            - -c
            - |
              pip install -q boto3 prometheus-client flask && \
              python -c "
              import os
              import boto3
              from datetime import datetime, timedelta
              from prometheus_client import Gauge, start_http_server
              import time

              # Initialize AWS clients
              ce = boto3.client('ce', region_name=os.environ.get('AWS_REGION', 'eu-west-2'))

              # Prometheus metrics
              current_month_cost = Gauge('aws_cost_exporter_current_month_cost', 'Current month cost', ['currency'])
              daily_cost = Gauge('aws_cost_exporter_daily_cost', 'Daily cost', ['date', 'currency'])
              forecasted_monthly = Gauge('aws_cost_exporter_forecasted_monthly_cost', 'Forecasted monthly cost', ['currency'])
              service_cost = Gauge('aws_cost_exporter_service_cost', 'Cost by service', ['service_name', 'currency'])
              remaining_credits = Gauge('aws_cost_exporter_remaining_credits', 'Remaining credits')

              def get_cost_and_usage(start, end, granularity='DAILY', group_by=None):
                  params = {
                      'TimePeriod': {'Start': start, 'End': end},
                      'Granularity': granularity,
                      'Metrics': ['BlendedCost']
                  }
                  if group_by:
                      params['GroupBy'] = group_by
                  return ce.get_cost_and_usage(**params)

              def update_metrics():
                  today = datetime.now()
                  month_start = today.replace(day=1).strftime('%Y-%m-%d')
                  today_str = today.strftime('%Y-%m-%d')
                  tomorrow_str = (today + timedelta(days=1)).strftime('%Y-%m-%d')
                  
                  # Current month cost
                  # Use DAILY granularity for partial months to get accurate sum
                  # MONTHLY granularity with partial month periods can return incorrect values
                  try:
                      result = get_cost_and_usage(month_start, today_str, 'DAILY')
                      if result['ResultsByTime']:
                          # Sum all daily costs for accurate partial month total
                          total_cost = sum(float(day['Total']['BlendedCost']['Amount']) 
                                          for day in result['ResultsByTime'])
                          currency = result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                          current_month_cost.labels(currency=currency).set(total_cost)
                  except Exception as e:
                      print(f'Error getting current month cost: {e}')
                  
                  # Daily cost
                  try:
                      result = get_cost_and_usage((today - timedelta(days=1)).strftime('%Y-%m-%d'), today_str, 'DAILY')
                      if result['ResultsByTime']:
                          cost = float(result['ResultsByTime'][0]['Total']['BlendedCost']['Amount'])
                          currency = result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                          daily_cost.labels(date=(today - timedelta(days=1)).strftime('%Y-%m-%d'), currency=currency).set(cost)
                  except Exception as e:
                      print(f'Error getting daily cost: {e}')
                  
                  # Cost by service
                  try:
                      result = get_cost_and_usage(month_start, today_str, 'MONTHLY', [{'Type': 'DIMENSION', 'Key': 'SERVICE'}])
                      if result['ResultsByTime']:
                          for group in result['ResultsByTime'][0]['Groups']:
                              service = group['Keys'][0] if group['Keys'] else 'Unknown'
                              cost = float(group['Metrics']['BlendedCost']['Amount'])
                              currency = group['Metrics']['BlendedCost']['Unit']
                              service_cost.labels(service_name=service, currency=currency).set(cost)
                  except Exception as e:
                      print(f'Error getting service cost: {e}')
                  
                  # Forecasted monthly cost (estimate based on current month average daily rate)
                  try:
                      month_result = get_cost_and_usage(month_start, today_str, 'MONTHLY')
                      if month_result.get('ResultsByTime'):
                          days_elapsed = (today - today.replace(day=1)).days + 1
                          if days_elapsed > 0:
                              current_cost = float(month_result['ResultsByTime'][0]['Total']['BlendedCost']['Amount'])
                              daily_avg = current_cost / days_elapsed
                              forecasted = daily_avg * 30
                              currency = month_result['ResultsByTime'][0]['Total']['BlendedCost']['Unit']
                              forecasted_monthly.labels(currency=currency).set(forecasted)
                  except Exception as e:
                      print(f'Error calculating forecasted monthly cost: {e}')
                  
                  # Remaining credits (placeholder - would need AWS Budgets API or manual input)
                  # For now, set to 0 or a default value
                  try:
                      remaining_credits.set(0)
                  except Exception as e:
                      print(f'Error setting remaining credits: {e}')

              # Start Prometheus metrics server
              start_http_server(8080)

              # Update metrics immediately on startup
              update_metrics()

              # Update metrics every hour
              while True:
                  time.sleep(3600)
                  update_metrics()
              "
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /metrics
              port: 8080
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /metrics
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
spec:
  type: ClusterIP
  ports:
    - port: 8080
      targetPort: 8080
      name: metrics
  selector:
    app: aws-cost-exporter
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: aws-cost-exporter
  namespace: finops
  labels:
    app: aws-cost-exporter
    release: kube-prometheus-stack
spec:
  selector:
    matchLabels:
      app: aws-cost-exporter
  endpoints:
    - port: metrics
      interval: 1m
      scrapeTimeout: 30s
      path: /metrics
